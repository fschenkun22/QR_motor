C51 COMPILER V9.53.0.0   UART                                                              09/08/2021 23:58:55 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN uart.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE uart.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include "reg51.h"
   2          #include "intrins.h"
   3          
   4          #define FOSC 11059200UL
   5          #define BRT (65536-FOSC/115200/4)
   6          
   7          #define MAIN_Fosc   11059200L //定义主时钟, 模拟串口和红外接收会自动适应。5~36MHZ
   8          
   9          #define D_TIMER0    125     //选择定时器时间, us, 红外接收要求在60us~250us之间
  10          
  11          #define User_code   0xFF00    //定义红外接收用户码
  12          
  13          #define freq_base     (MAIN_Fosc / 1200)
  14          #define Timer0_Reload   (65536 - (D_TIMER0 * freq_base / 10000))
  15          
  16          
  17          //****************本地变量************//
  18          bit busy;
  19          char wptr;
  20          char rptr;
  21          char buffer[16];
  22          sbit  P_IR_RX = P5^4;   //红外
  23          
  24          
  25          bit   P_IR_RX_temp;   //Last sample
  26          bit   B_IR_Sync;      //已收到同步标志
  27          unsigned char IR_SampleCnt;   //采样计数
  28          unsigned char IR_BitCnt;      //编码位数
  29          unsigned char IR_UserH;     //用户码(地址)高字节
  30          unsigned char IR_UserL;     //用户码(地址)低字节
  31          unsigned char IR_data;      //数据原码
  32          unsigned char IR_DataShit;    //数据反码
  33          
  34          bit   B_IrUserErr;    //User code error flag
  35          bit   B_IR_Press;     //Key press flag,include repeat key.
  36          unsigned char IR_code;      //IR code 红外键码
  37          
  38          /*************  本地函数声明  **************/
  39          
  40          unsigned char   HEX2ASCII(unsigned char dat);
  41          void  InitTimer(void);
  42          
  43          
  44          //*************串口********************//
  45          void UartIsr() interrupt 4{
  46   1          if(TI){
  47   2              TI = 0;
  48   2              busy = 0;
  49   2          }
  50   1          if(RI){
  51   2              RI = 0;
  52   2              buffer[wptr++] = SBUF;
  53   2              wptr&=0x0f;
  54   2          }
  55   1      }
C51 COMPILER V9.53.0.0   UART                                                              09/08/2021 23:58:55 PAGE 2   

  56          void UartInit(){
  57   1          SCON = 0x50;
  58   1          TMOD = 0x00;
  59   1          TL1 = BRT;
  60   1          TH1 = BRT>>8;
  61   1          TR1 = 1;
  62   1          AUXR = 0x40;
  63   1          wptr = 0x00;
  64   1          rptr = 0x00;
  65   1          busy = 0;
  66   1      }
  67          void UartSend(char dat){
  68   1          while(busy);
  69   1          busy = 1;
  70   1          SBUF = dat;
  71   1      }
  72          void UartSendStr(char *p){
  73   1          while(*p)
  74   1          {
  75   2              UartSend(*p++);
  76   2          }
  77   1      }
  78          //**************************************
  79          
  80          void main(){
  81   1          P3M0 = 0x00;
  82   1          P3M1 = 0x00;
  83   1          InitTimer();
  84   1          UartInit();
  85   1          ES = 1;
  86   1          EA = 1;
  87   1          UartSendStr("Uart send test \r\n");
  88   1      
  89   1          while(1){
  90   2              if(B_IR_Press){
  91   3                  
  92   3                  B_IR_Press = 0;   //清除IR键按下标志
  93   3                  UartSendStr("have");
  94   3                  UartSend(HEX2ASCII(IR_code>>4));
  95   3                  UartSend(HEX2ASCII(IR_code));
  96   3                  IR_code = 0;
  97   3              }
  98   2          }
  99   1      }
 100          
 101          /********************* 十六进制转ASCII函数 *************************/
 102          unsigned char HEX2ASCII(unsigned char dat)
 103          {
 104   1        dat &= 0x0f;
 105   1        if(dat <= 9)  return (dat + '0'); //数字0~9
 106   1        return (dat - 10 + 'A');      //字母A~F
 107   1      }
 108          
 109          
 110          
 111          /******************** 红外采样时间宏定义, 用户不要随意修改  *******************/
 112          
 113          #if ((D_TIMER0 <= 250) && (D_TIMER0 >= 60))
 114          #define D_IR_sample     D_TIMER0    //定义采样时间，在60us~250us之间
 115          #endif
 116          
 117          #define D_IR_SYNC_MAX   (15000/D_IR_sample) //SYNC max time
C51 COMPILER V9.53.0.0   UART                                                              09/08/2021 23:58:55 PAGE 3   

 118          #define D_IR_SYNC_MIN   (9700 /D_IR_sample) //SYNC min time
 119          #define D_IR_SYNC_DIVIDE  (12375/D_IR_sample) //decide data 0 or 1
 120          #define D_IR_DATA_MAX   (3000 /D_IR_sample) //data max time
 121          #define D_IR_DATA_MIN   (600  /D_IR_sample) //data min time
 122          #define D_IR_DATA_DIVIDE  (1687 /D_IR_sample) //decide data 0 or 1
 123          #define D_IR_BIT_NUMBER   32          //bit number
 124          
 125          //*******************************************************************************************
 126          
 127          //**************************** IR RECEIVE MODULE ********************************************
 128          
 129          void IR_RX_HT6121(void)
 130          {
 131   1        unsigned char SampleTime;
 132   1      
 133   1        IR_SampleCnt++;             //Sample + 1
 134   1      
 135   1        F0 = P_IR_RX_temp;            //Save Last sample status
 136   1        P_IR_RX_temp = P_IR_RX;         //Read current status
 137   1        if(F0 && !P_IR_RX_temp)         //Last sample is high，and current sample is low, so is fall edge
 138   1        {
 139   2          SampleTime = IR_SampleCnt;      //get the sample time
 140   2          IR_SampleCnt = 0;         //Clear the sample counter
 141   2      
 142   2             if(SampleTime > D_IR_SYNC_MAX)   B_IR_Sync = 0;  //large the Maxim SYNC time, then error
 143   2          else if(SampleTime >= D_IR_SYNC_MIN)          //SYNC
 144   2          {
 145   3            if(SampleTime >= D_IR_SYNC_DIVIDE)
 146   3            {
 147   4              B_IR_Sync = 1;          //has received SYNC
 148   4              IR_BitCnt = D_IR_BIT_NUMBER;  //Load bit number
 149   4            }
 150   3          }
 151   2          else if(B_IR_Sync)            //has received SYNC
 152   2          {
 153   3            if(SampleTime > D_IR_DATA_MAX)    B_IR_Sync=0;  //data samlpe time to large
 154   3            else
 155   3            {
 156   4              IR_DataShit >>= 1;          //data shift right 1 bit
 157   4              if(SampleTime >= D_IR_DATA_DIVIDE)  IR_DataShit |= 0x80;  //devide data 0 or 1
 158   4              if(--IR_BitCnt == 0)        //bit number is over?
 159   4              {
 160   5                B_IR_Sync = 0;          //Clear SYNC
 161   5                if(~IR_DataShit == IR_data)   //判断数据正反码
 162   5                {
 163   6                  if((IR_UserH == (User_code / 256)) &&
 164   6                    IR_UserL == (User_code % 256))
 165   6                      B_IrUserErr = 0;  //User code is righe
 166   6                  else  B_IrUserErr = 1;  //user code is wrong
 167   6                    
 168   6                  IR_code      = IR_data;
 169   6                  B_IR_Press   = 1;     //数据有效
 170   6                }
 171   5              }
 172   4              else if((IR_BitCnt & 7)== 0)    //one byte receive
 173   4              {
 174   5                IR_UserL = IR_UserH;      //Save the User code high byte
 175   5                IR_UserH = IR_data;       //Save the User code low byte
 176   5                IR_data  = IR_DataShit;     //Save the IR data byte
 177   5              }
 178   4            }
 179   3          }
C51 COMPILER V9.53.0.0   UART                                                              09/08/2021 23:58:55 PAGE 4   

 180   2        }
 181   1      }
 182          
 183          
 184          /**************** Timer初始化函数 ******************************/
 185          void InitTimer(void)
 186          {
 187   1        TMOD = 0;   //for STC15Fxxx系列 Timer0 as 16bit reload timer.
 188   1        TH0 = Timer0_Reload / 256;
 189   1        TL0 = Timer0_Reload % 256;
 190   1        ET0 = 1;
 191   1        TR0 = 1;
 192   1      
 193   1        EA  = 1;
 194   1      }
 195          
 196          
 197          /********************** Timer0中断函数************************/
 198          void timer0 (void) interrupt 1
 199          {
 200   1        IR_RX_HT6121();
 201   1      }
 202          
 203          
 204          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    356    ----
   CONSTANT SIZE    =     23    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     25       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
